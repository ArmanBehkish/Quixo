function minimax(node, depth, maximizingPlayer) is
    if depth = 0 or node is a terminal node then
        return the heuristic value of node
    if maximizingPlayer then
        value := −∞
        for each child of node do
            value := max(value, minimax(child, depth − 1, FALSE))
        return value
    else (* minimizing player *)
        value := +∞
        for each child of node do
            value := min(value, minimax(child, depth − 1, TRUE))
        return value

def minimax(state, max_depth, is_player_minimizer, alpha, beta):
    if max_depth == 0 or state.is_end_state():
        return evaluation_function(state)

    if is_player_minimizer:
        value = -math.inf
        for move in state.possible_moves():
            evaluation = minimax(move, max_depth - 1, False, alpha , beta)
            min = min(value, evaluation)
            # Keeping track of our current best score
            beta = min(beta, evaluation)
            if beta <= alpha:
                break
        return value

    value = math.inf
    for move in state.possible_moves():
        evaluation = minimax(move, max_depth - 1, True, alpha, beta)
        max = max(value, evaluation)
        # Keeping track of our current best score
        alpha = max(alpha, evaluation)
        if beta <= alpha:
            break
    return value




suggestions for score function:
win-loss-draw check
control the center positions
nodes that will result in quicker wins compared to those that needs many moves to win can be higher
the number of possible moves that a player can make in a state
number of opportunities that a player has to win
# of consecutive pieces a player has in a row, col, or diagonal
number of lines player can still win (unblocked lines)



In a full m-ary tree, the total number of nodes up to depth n is given by:

Total number of nodes=m(n+1)−1m−1Total number of nodes=m−1m(n+1)−1​

However, to find the number of leaves (which are the nodes at the deepest level), you only need to calculate the number of nodes at that level, since all nodes at the deepest level are leaves. In a tree with a constant branching factor, each level has m times more nodes than the level above it.

At depth n (considering the root node is at depth 0), the number of leaves (or nodes at depth n) is:

Number of leaves=mnNumber of leaves=mn




========================================================================
RESULTS (100 games)

minmax, normal, aginst random, first player:  win percentage: 91/100
minmax, normal, against random, second player: win percentage: 87/100
minmax, alpha beta, aginst random, first player: 
minmax, alpha beta, against random, second player: 


these are with correct winner check:

fail-hard variation
minmax, alpha beta, with memory, aginst random, first player:    MinMaxAlphaBeta with memory Agent with depth 3 won 72 times and Random Player Agent won 28 in 15 minutes!


minmax, alpha beta, with memory, against random, second player: 
Random Player Agent won 22 times and MinMaxAlphaBeta with memory Agent with depth 3 won 78 in 15 minutes!

agent works both when playing first or second


with depth 4:
 Random Player Agent won 6 times and MinMaxAlphaBeta with memory Agent with depth 4 won 94 in 114 minutes!


in simplple minmax agent, tried monte carlo roll-out for static evaluation of terminal nodes. it was too slow to be useful

 Random Player Agent won 29 times and MinMaxAlphaBeta with memory Agent with depth 3 won 71 in 15.801696713765462 minutes!


 Random Player Agent won 28 times and MinMaxAlphaBeta Agent with depth 3 won **72** in 76.30714883804322 minutes! (almost 45 seconds per game)

 MinMaxAlphaBeta with memory Agent with ***depth 3*** won ***81 times*** and Random Player Agent won 19 in 13.81549804210663 minutes (***8.5 seconds*** to finish each game)!

MinMaxAlphaBeta with memory Agent with **depth 4** won ***95 times*** and Random Player Agent won 5 in 89.74851703246435 minutes!  (almost ***53 seconds*** per game)


 Random Player Agent won 18 times and MinMaxAlphaBeta with memory Agent with depth 3 won 82 in 14.87390695810318 minutes!  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
alpha-beta fail-hard

function alphabeta(node, depth, α, β, maximizingPlayer) is
    if depth == 0 or node is terminal then
        return the heuristic value of node
    if maximizingPlayer then
        value := −∞
        for each child of node do
            value := max(value, alphabeta(child, depth − 1, α, β, FALSE))
            if value > β then
                break (* β cutoff *)
            α := max(α, value)
        return value
    else
        value := +∞
        for each child of node do
            value := min(value, alphabeta(child, depth − 1, α, β, TRUE))
            if value < α then
                break (* α cutoff *)
            β := min(β, value)
        return value

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
alpha-beta fail-soft

function alphabeta(node, depth, α, β, maximizingPlayer) is
    if depth == 0 or node is terminal then
        return the heuristic value of node
    if maximizingPlayer then
        value := −∞
        for each child of node do
            value := max(value, alphabeta(child, depth − 1, α, β, FALSE))
            α := max(α, value)
            if value ≥ β then
                break (* β cutoff *)
        return value
    else
        value := +∞
        for each child of node do
            value := min(value, alphabeta(child, depth − 1, α, β, TRUE))
            β := min(β, value)
            if value ≤ α then
                break (* α cutoff *)
        return value